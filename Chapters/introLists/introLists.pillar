{
	"title": "Intro Lists",
	"attribution": "Coen"
}

Typ op de command line
[[[
elm-repl
]]]

REPL staat voor ... (google hier eens op).

We kunnen nu ==elm expressies== intypen die dan direct geëvalueerd worden. Bijvoorbeeld:

[[[
42
]]]
Reactie:
[[[
42 : number
]]]
ofwel ==repl== heeft gezien dat het resultaat ==42== is en dat dit een ''getal'' (==number==) is.

Iets spannender (denk even na of je het antwoord van deze vermeningvuldiging
makkelijk zelf zou kunnen berekenen)
[[[
42 * 38
]]]
Hee, je kunt het dus als rekenmachine gebruiken...
Enfin, je bent waarschijnlijk niet heel erg verbaasd.

Inderdaad kun je met ==+==, ==-==, ==*== en ==/== optellen, aftrekken, vermenigvuldign en delen.

Wat denk je dat er uitkomt als je
[[[
12 + 3 * 2
]]]
intypt? Houdt ==elm== rekening met de volgorde van berekening?
Wordt eerst de ==+== of eerst ==*== uitgevoerd? Ofwel: is dit gelijk aan
==( 12 + 3 ) * 2== of juist aan == 12 + ( 3 * 2) ==?

!!!!Reken
Als je zelf de volgorde wil aangeven kun je er voor kiezen op de volgende manier te
rekenen:
[[[
add(12, multiply(3,2))
]]]
Hierbij worden er 2 dingen opgeteld (''add''): het eerste is een getal, het andere is
de uitkomst van de vermenigvuldiging van 3 en 2 (''multiply'').

Stel er zou staan:
[[[
multiply(add(12,3),2)
]]]
dan zou juist de uitkomst van ==12+3== vermenigvuldigd worden met 2.

Nu is ''add'' een functie die
normaalgesproken 2 parameters krijgt, maar in de taal ==elm== kun je de
parameters 1 voor 1 aan een functie voeren. De combinatie
==add 2== is een optelfunctie die al weet dat ie ''2+..'' gaat doen.

Nu zijn ==add== en ==multiply== al bestaande ==functies==. Je kunt ook zelf
nieuwe functies erbij programmeren. Met bijvoorbeeld
[[[
telTweeOpBij = add 2
]]]
wordt een nieuwe ==functie== ''telTweeOpBij'' (deze naam kun je dus zelf kiezen)
gedefinieerd door de  al genoemde
==add 2== constructie (deze combinatie ís ook weer een functie).
Na deze definitie kun je schrijven
[[[
telTweeOpBij 5
]]]
Onthoud dit even, we komen hier zo op terug.

!!!!Lists
Typ eens in:
[[[
List.range 1 9
]]]
Resultaat:
[[[
[1,2,3,4,5,6,7,8,9] : List Int
]]]
Hee, hoe komt dat? Blijkbaar wordt er een ''lijstje'' van getallen opgebouwd.

Ook kun je aan een bestaande ==List== met \:\: een element toevoegen:
[[[
42 :: (List.range 1 9)
]]]
en ook meerdere elementen kan
[[[
83 :: 42 :: (List.range 1 9)
]]]
Zoals je ziet zijn haakjes niet nodig.



!!!!En tel er 2 bij op...
Het leuke van ==Lists== is dat je er berekeningen op kunt gaan toepassen.
Stel we willen bij elk getal in de ==List== het getal 2 optellen.
We ''mappen'' dan de ==functie== ''telTweeOpBij'' op
""elk"" getal uit de ==List==:








@@todo vanaf hier zijn het nog losse opmerkingen waar nog iets mee moet...
@@todo Map
@@todo Fold
@@todo Filter


!!!!Vorm van een List
Als een ==List== niet leeg is is ie van de vorm
[[[
element :: eenAndereList
]]]
Het ''element'' voorop noemen we ook wel het ''kop-element'' (==head==),
dit wordt ""voor"" de rest (een iets kortere ==List== genaamd ''eenAndereList'')
geplakt. De enige ==List== die niet van deze vorm is is de lege ==List==
die we noteren als ==[]==.










@@todo vanaf hier zijn het nog losse opmerkingen waar nog iets mee moet...

[ 'y' 'u' ]

!!!!Lengte van een List (~recursiviteit)



Aangezien er heel vaak met ==Lists== gewerkt wordt is het handig dat
er verschillende
manieren om een ==List== te construeren:
Je kunt de elementen opnoemen
[[[
[2,3,5,7,13,24,57,56,33,21,3,2]
]]]
Let op dat er een volgorde in zit en elementen dubbel kunnen voorkomen.



[[[
import Html exposing (text)


main =
  text (toString (length (List.range 1 9)))


{-| Figure out the length of any list. To find the length of
list [6,6,6] we need to know that this devilish list is just
a convenient way to write (6 :: (6 :: (6 :: []))) where
the :: operator is putting an element on the front of a list.
Evaluation looks like this:

    length (6 :: (6 :: (6 :: [])))
    1 + (length (6 :: (6 :: [])))
    1 + (1 + (length (6 :: [])))
    1 + (1 + (1 + length []))
    1 + (1 + (1 + 0))
    1 + (1 + 1)
    1 + 2
    3

Stepping through evaluation like this can be really helpful
for building intuition about recursive functions.
-}
length : List a -> Int
length list =
  case list of
    [] ->
        0

    first :: rest ->
        1 + length rest


{- EXPLANATION

The 'length' function figures out the length of any list. We
use the 'case' keyword to "pattern match" on the structure of
the list.

Lists can either be empty [] or a pair of an element and a
sublist like (1 :: []) or (1 :: (2 :: []))

To write 'length' we have two cases to think about:

  1. If the list is empty, the length is zero.
  2. If the list is not empty, the length is 1 more than
     however long the rest of the list is.

When you write a function like 'length', always pretend that
you already succeeded. So when we need to know how long the
rest of the list is, we can pretend 'length' is already done
and use it!
-}
]]]

!!!!Telgetallen


!!!!Fibonacci reeks?


!!!!Anonymous functions
[[[
\x -> x + 1

\x y -> x + y
]]]

!!!!Named functions
[[[
addOne : Int -> Int
addOne x =
  x + 1
]]]

 In Elm all functions take exactly one argument and return a result.
 This result can be another function.
