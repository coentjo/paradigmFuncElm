!!Installeren ELM en eerste kennismaking


Ik heb de duidelijke instructie gevolgd over het installeren van
de ''Atom'' editor op
*elm tutorial>https://guide.elm-lang.org/*.
Atom blijkt een erg prettige editor die ik iedereen aan kan raden!

In ''Atom'' heb ik zoals aangeraden ==package== ''language-elm'' geïnstalleerd.

==AutoComplete== door uit te voeren:

[[[
npm install -g elm-oracle
]]]

Persisson error: ==sudo== needed. Hiermee lukte het.

%toch niet: Installed ==atom-beautify==.

Tested: ==elm-repl==

Tested: ==elm-reactor==
door het clonen van git-repos
*https://github.com/evancz/elm-architecture-tutorial.git>https://github.com/evancz/elm-architecture-tutorial.git*
en commando ==elm-reactor== te geven in die dir.

De voorbeelden bekeken.

!!!01-button: Increase / Decrease

Open 2 tabs op dezelfde app en je ziet dat ze elk een eigen sessie hebben.

De ==back==-button brengt je meteen(!) terug in het ''menu''.

Een elm-programma ziet er alsvolgt uit:
[[[
main =
  Html.beginnerProgram
    { model = model
    , view = view
    , update = update
    }
]]]
De naam ''beginnerProgram'' lijkt een bestaande naam te zijn, of is het de
naam die de programmeur aan dit programma geeft??

De indeling doet erg denken aan ==Model View Controller==.

[[[
type alias Model = Int
model : Model
view : Model -> Html Msg
update : Msg -> Model -> Model
]]]
Dit laat zien dat het ==model== letterlijk een getal is,
de ==view== is een ==function== die, gegeven een ''Model'',
een ''Html Msg'' teruggeeft: een ''Html''-page én(?) een ''Msg''?
De ==update== tot slot is een ==function== gegeven een ''Msg'' een
==function== terug geeft die een ''Model'' omzet naar een nieuw ''Model''.

@@note doet erg aan een ==transition function== bij een ''eindige machine'' denken.

De ==Msg== wordt met een ''enumeratie'' gedefineerd
[[[
type Msg
  = Increment
  | Decrement
]]]

en de function ''update'' met parameters ''msg'' en ''model'' als
[[[
update msg model =
  case msg of
    Increment ->
      model + 1

    Decrement ->
      model - 1
]]]
Ik vraag me af of ik deze function kan gebruiken als ==update msg==
(dus dat er een nieuwe function uitkomt van type ==Model -> Model==)?

De code ziet er elegant uit!

Om het af te maken wordt met
[[[
view model =
  div []
    [ button [ onClick Decrement ] [ text "-" ]
    , div [] [ text (toString model) ]
    , button [ onClick Increment ] [ text "+" ]
    ]
]]]
(blijkbaar) gedefinieerd dat
-div een ==div==-element aan de html toevoegt.
-button een button, met aan de onClick de ''Msg'' ''Decrement'' (of ''Increment'' bij de andere), en de opgegeven ''text''.

De ==[]== suggereert dat er een ''array''-achtige constructie (''sequentie''?) gebruikt wordt.




!!!02-field: ''nerovetsrethca''.
Tip een woord in en (na elk getypt karakter) wordt
de ''achterstevoren'' versie in de page geplaatst.


!!!03-form Passwords do(n't) match
name-veld en dubbel passwd-veld.

[[[
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onInput)
]]]
Suggereert dat met ==..== ''alle'' html-tags en html-attributes
(en wrschnlk ook ''Events'') toegankelijk zouden
kunnen worden in dit programma. Van de ''Events'' wordt blijkbaar alleen
het ==onInput== toegevoegd.

Het type voor het model (''Model'') bestaat dit keer (leid ik af) uit een tupel van 3 strings,
respectievelijk met de namen ==name==, ==password== en ==passwordAgain==:
[[[
type alias Model =
  { name : String
  , password : String
  , passwordAgain : String
  }

model : Model
model =
  Model "" "" ""
]]]
en de strings beginnen alledrie met een lege string als waarde.

[[[

type Msg
    = Name String
    | Password String
    | PasswordAgain String


update : Msg -> Model -> Model
update msg model =
  case msg of
    Name name ->
      { model | name = name }

    Password password ->
      { model | password = password }

    PasswordAgain password ->
      { model | passwordAgain = password }



-- VIEW


view : Model -> Html Msg
view model =
  div []
    [ input [ type_ "text", placeholder "Name", onInput Name ] []
    , input [ type_ "password", placeholder "Password", onInput Password ] []
    , input [ type_ "password", placeholder "Re-enter Password", onInput PasswordAgain ] []
    , viewValidation model
    ]


viewValidation : Model -> Html msg
viewValidation model =
  let
    (color, message) =
      if model.password == model.passwordAgain then
        ("green", "OK")
      else
        ("red", "Passwords do not match!")
  in
    div [ style [("color", color)] ] [ text message ]

]]]


!!!04-random
Dobbelsteen.
